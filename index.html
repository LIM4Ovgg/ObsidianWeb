<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8" />
    <title>Visualizador Obsidian Canvas</title>
    <style>
        body {
            margin: 0;
            background: #202020;
            color: #fff;
            font-family: Arial, sans-serif;
            text-align: center;
        }

        header {
            padding: 16px;
            background: #1a1a1a;
            box-shadow: 0 2px 4px rgba(0, 0, 0, .5);
        }

        #canvas-container {
            height: 90vh;
            position: relative;
            overflow: hidden;
            cursor: grab;
        }

        #canvas-inner {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
        }

        .node {
            position: absolute;
            border-radius: 8px;
            padding: 8px;
            background: #2c2c2c;
            color: #fff;
            text-align: center;
            overflow: hidden;
            z-index: 1;
            /* nós acima/abaixo do svg controlado abaixo */
        }

        .node img {
            max-width: 100%;
            max-height: 100%;
        }

        /* SVG cobre todo o canvas; nada é cortado e continua alinhado 1:1 com os nós */
        svg {
            position: absolute;
            top: 0;
            left: 0;
            overflow: visible;
            pointer-events: none;
            z-index: 0;
            /* deixa as linhas por cima dos nós (garante seta visível) */
        }

        /* só estiliza as arestas geradas, não mexe no <path> do <defs> */
        path.edge {
            stroke: #aaa;
            stroke-width: 2;
            stroke-linecap: round;
            fill: none;
            marker-end: url(#arrow);
            vector-effect: non-scaling-stroke;
            /* zoom não deforma a espessura */
        }

        #fileInput {
            margin: 10px;
            padding: 10px 20px;
            font-size: 14px;
            border: none;
            border-radius: 8px;
            background: #8e44ad;
            color: #fff;
            cursor: pointer;
        }

        #fileInput:hover {
            background: #732d91;
        }
    </style>
</head>

<body>
    <header>
        <h1>🧠 Visualizador de Canvas do Obsidian</h1>
        <input type="file" id="fileInput" multiple webkitdirectory />
    </header>

    <div id="canvas-container">
        <div id="canvas-inner">
            <svg id="edges" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <!-- Marcador da seta (triângulo). NÃO remover! -->
                    <marker id="arrow" markerWidth="12" markerHeight="12" refX="10" refY="6" orient="auto"
                        markerUnits="userSpaceOnUse">
                        <path d="M0,0 L0,12 L12,6 Z" fill="#aaa" />
                    </marker>
                </defs>
            </svg>
        </div>
    </div>

    <script>
        const container = document.getElementById("canvas-container");
        const inner = document.getElementById("canvas-inner");
        const edgesSvg = document.getElementById("edges");

        let scale = 1, originX = 0, originY = 0, isPanning = false, startX, startY;

        // -------- PAN --------
        container.addEventListener("mousedown", e => {
            isPanning = true;
            startX = e.clientX - originX;
            startY = e.clientY - originY;
            container.style.cursor = "grabbing";
        });
        container.addEventListener("mouseup", () => {
            isPanning = false;
            container.style.cursor = "grab";
        });
        container.addEventListener("mousemove", e => {
            if (!isPanning) return;
            originX = e.clientX - startX;
            originY = e.clientY - startY;
            updateTransform();
        });

        // -------- ZOOM --------
        container.addEventListener("wheel", e => {
            e.preventDefault();
            const zoom = 1.1;
            const mouseX = e.clientX - container.offsetLeft;
            const mouseY = e.clientY - container.offsetTop;

            if (e.deltaY < 0) {
                scale *= zoom;
                originX = mouseX - (mouseX - originX) * zoom;
                originY = mouseY - (mouseY - originY) * zoom;
            } else {
                scale /= zoom;
                originX = mouseX - (mouseX - originX) / zoom;
                originY = mouseY - (mouseY - originY) / zoom;
            }
            updateTransform();
        }, { passive: false });

        function updateTransform() {
            inner.style.transform = `translate(${originX}px, ${originY}px) scale(${scale})`;
        }

        // Calcula ponto na borda do retângulo saindo do centro em direção a (tx,ty)
        // extra > 0 empurra para fora do retângulo (linha fica mais curta).
        function pointOnRectEdge(cx, cy, w, h, tx, ty, extra = 8) {
            const dx = tx - cx, dy = ty - cy;
            if (dx === 0 && dy === 0) return { x: cx, y: cy };
            const hx = w / 2, hy = h / 2;

            const tX = dx === 0 ? Infinity : Math.abs(hx / dx);
            const tY = dy === 0 ? Infinity : Math.abs(hy / dy);
            const t = Math.min(tX, tY);

            let x = cx + dx * t;
            let y = cy + dy * t;

            const len = Math.hypot(dx, dy) || 1;
            x += (dx / len) * extra;
            y += (dy / len) * extra;

            return { x, y };
        }

        document.getElementById("fileInput").addEventListener("change", async (event) => {
            const files = Array.from(event.target.files);

            // índice p/ achar imagens locais
            const fileMap = {};
            files.forEach(f => fileMap[f.name] = f);

            const canvasFile = files.find(f => f.name.endsWith(".canvas"));
            if (!canvasFile) {
                alert("Nenhum arquivo .canvas encontrado!");
                return;
            }

            const reader = new FileReader();
            reader.onload = async e => {
                const data = JSON.parse(e.target.result);

                // LIMPA (somente as arestas geradas; preserva <defs> e o marcador)
                inner.querySelectorAll(".node").forEach(el => el.remove());
                edgesSvg.querySelectorAll(":scope > path.edge").forEach(el => el.remove());

                const nodes = {};
                let maxX = 0, maxY = 0;

                // ----- NÓS -----
                for (const node of data.nodes) {
                    const div = document.createElement("div");
                    div.className = "node";
                    div.style.left = node.x + "px";
                    div.style.top = node.y + "px";
                    div.style.width = node.width + "px";
                    div.style.height = node.height + "px";

                    if (node.type === "text") {
                        div.textContent = node.text;
                    } else if (node.type === "file" && node.file) {
                        const img = document.createElement("img");
                        const lower = node.file.toLowerCase();
                        if (fileMap[node.file]) {
                            const imgReader = new FileReader();
                            imgReader.onload = ev => img.src = ev.target.result;
                            imgReader.readAsDataURL(fileMap[node.file]);
                        } else if (/\.(png|jpg|jpeg|svg)$/.test(lower)) {
                            img.src = node.file;
                        } else {
                            img.alt = "Arquivo não encontrado: " + node.file;
                        }
                        div.appendChild(img);
                    } else {
                        div.textContent = node.id;
                    }

                    inner.appendChild(div);
                    nodes[node.id] = { x: node.x, y: node.y, w: node.width, h: node.height };

                    maxX = Math.max(maxX, node.x + node.width);
                    maxY = Math.max(maxY, node.y + node.height);
                }

                // ----- DIMENSIONA O SVG PARA COBRIR TODO O CANVAS -----
                const margin = 300;
                const svgW = Math.max(maxX + margin, container.clientWidth);
                const svgH = Math.max(maxY + margin, container.clientHeight);
                edgesSvg.setAttribute("width", svgW);
                edgesSvg.setAttribute("height", svgH);
                edgesSvg.removeAttribute("viewBox"); // 1:1 com coordenadas dos nós

                // ----- ARESTAS (Bezier curta) -----
                for (const edge of (data.edges || [])) {
                    const from = nodes[edge.fromNode];
                    const to = nodes[edge.toNode];
                    if (!from || !to) continue;

                    const c1x = from.x + from.w / 2, c1y = from.y + from.h / 2;
                    const c2x = to.x + to.w / 2, c2y = to.y + to.h / 2;

                    // comece/termine FORA da borda para a seta aparecer
                    const start = pointOnRectEdge(c1x, c1y, from.w, from.h, c2x, c2y, 10);
                    const end = pointOnRectEdge(c2x, c2y, to.w, to.h, c1x, c1y, 10);

                    // curvatura mais curta e suave
                    const dx = end.x - start.x, dy = end.y - start.y;
                    const k = 0.28; // 0.25~0.35 funciona bem
                    const cx1 = start.x + dx * k, cy1 = start.y + dy * k;
                    const cx2 = end.x - dx * k, cy2 = end.y - dy * k;

                    const d = `M ${start.x} ${start.y} C ${cx1} ${cy1}, ${cx2} ${cy2}, ${end.x} ${end.y}`;
                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    path.setAttribute("class", "edge");
                    path.setAttribute("d", d);
                    edgesSvg.appendChild(path);
                }

                // reset navegação
                scale = 1; originX = 0; originY = 0; updateTransform();
            };
            reader.readAsText(canvasFile);
        });
    </script>
</body>

</html>